# -*- coding: utf-8 -*-
"""ManyCore_HW2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NGWJsIw9caVL3M3LbwiC3OOSz2ikO7jG
"""



import random
import numpy as np
from copy import deepcopy
from dataclasses import dataclass
import pandas as pd
import math
import networkx as nx
import time
from sklearn.ensemble import RandomForestRegressor
import collections

def mesh_generate():
    
    #Generating the mesh configuration
    
    core_connect=[]
    for k in range(63):
        # Last row cores are only connected to next core and the above core 
        if k in [56,57,58,59,60,61,62,63]:  
            core_connect.append([k,k+1])
        # Extreme right cores are only connected to bottom cores.
        elif k in [7,15,23,31,39,47,55]:    
            core_connect.append([k,k+8])
        # Cores that are connected to the next as well as the bottom cores
        else:
            core_connect.append([k,k+1])
            core_connect.append([k,k+8])
    
    return core_connect

def adj_matrix(coreConnections):
    
    
    shape=(64,64) 
    # Cores are arranged in 8x8 grid 
    matrix_mesh=np.zeros(shape)
    # The value of matrix is 1 where connections are present otherwise 0 is present.
    for connect in coreConnections:
            matrix_mesh[connect[1]][connect[0]]=1
            matrix_mesh[connect[0]][connect[1]]=1
           
    return matrix_mesh

def core_link(adjMatrix,core1,core2): 
    
       
    network_Adj=nx.from_numpy_matrix(adjMatrix,create_using=nx.DiGraph())
    # Calculating the shortest path between cores
    dijkstra_length=nx.shortest_path_length(network_Adj,core1,core2)
    if dijkstra_length > 4:
        return 0
    else:
        return 1

def link_swap(core1,core2,Scurrent,Tcurrent):
    
     
    # Creating a copy, so that all the new connections are not updated in the original adj matrix.
    Scurrent_copy=deepcopy(Scurrent)   
    core_connected=[]
    core_count=-1
    num_links=np.sum(Scurrent_copy[core2])  
    if num_links < 7:
        for k in Scurrent_copy[core1]:
            core_count+=1
            if k==1:
                core_connected.append(core_count)
        # Randomly choosing a core connected to core 1 
        coreLink_destroy=random.choice(core_connected)
        # checking whether the chosen core has only one connection.
        if (np.sum(Scurrent_copy[coreLink_destroy])==1):  
            perturbation(Scurrent,Tcurrent)
        else:
            # Creating new links between core 1 and core 2 while destroying one of the link of core 1.
            Scurrent_copy[core1][coreLink_destroy]=0
            Scurrent_copy[coreLink_destroy][core1]=0
            Scurrent_copy[core1][core2]=1
            Scurrent_copy[core2][core1]=1                
    else:
        perturbation(Scurrent,Tcurrent)
    return Scurrent_copy

def swap_tile(core1,core2,Tcurrent):
    
       
    Tcurrent_copy=deepcopy(Tcurrent)
    Tcurrent_copy[core1], Tcurrent_copy[core2] = Tcurrent_copy[core2], Tcurrent_copy[core1]
    return Tcurrent_copy

def perturbation(Scurrent,Tcurrent):
    
      
    
    link_tile = random.randint(0,1)
    valid_core=0
   #randomly allocating tasks to the cores.
    core_1=random.randint(0,63)
    core_2=random.randint(0,63)
    # create a copy of the original adj matrix to avoid changes in the original matrix
    S_new = deepcopy(Scurrent)
    T_new = deepcopy(Tcurrent)
    # perturbation is called if the cores generated are same or the cores are already connected.
    if (Scurrent[core_1][core_2]==1 or core_1==core_2):
        perturbation(Scurrent,Tcurrent)
    else:
        if link_tile==0:
            
            valid_core=core_link(Scurrent,core_1,core_2)
            if valid_core == 1:
                S_new=link_swap(core_1,core_2,Scurrent,Tcurrent)
            elif valid_core == 0:
                perturbation(Scurrent,Tcurrent)
        elif link_tile==1:
            
            T_new=swap_tile(core_1,core_2,Tcurrent)
    return S_new,T_new

def calculate_distance(num_nodes,grid):
    
       
    distance_Matrix = np.zeros((num_nodes,num_nodes))
    for row in range(num_nodes):
        val =row / grid
        x_coordinate = (int)(val)
        y_coordinate = row % grid
        for column in range(num_nodes):
            val=column / grid
            xn_coordinate = (int)(val)
            yn_coordinate = column % grid
            x_distance = (xn_coordinate-x_coordinate)**2
            y_distance = (yn_coordinate-y_coordinate)**2
            # Calculating the distance between the two cores.
            distance_Matrix[row][column] = (x_distance + y_distance)**0.5
    return distance_Matrix

def hop_count(adj_matrix,num_nodes):
    
     
    hop_Count=np.zeros((num_nodes,num_nodes))  #  64x64 of all zeros
    network_Adj=nx.from_numpy_matrix(adj_matrix,create_using=nx.DiGraph())
    for j in range(num_nodes):
        for k in range(num_nodes):
             # calculating the shortest path.
            hop_Count[j][k]=nx.shortest_path_length(network_Adj,j,k)  
    return hop_Count

def link_length(adj_matrix,distance,num_nodes):
       
    LinkLength=np.zeros((num_nodes,num_nodes))
    # Calculating the distance between the cores.
    length_matrix=np.multiply(adj_matrix,distance)    
    network_length=nx.from_numpy_matrix(length_matrix,create_using=nx.DiGraph())
    path_dijkstra=[]
    for i in range(num_nodes):
        for j in range(num_nodes):
            if i==j:
                LinkLength[i][j]=0
            else:
                # Calculting the Dijkstra shortest path between the cores
                path_dijkstra=nx.dijkstra_path(network_length,i,j)
                source_destination=[]
                path_length=[]
                for x in range(len(path_dijkstra)-1):
                    source_destination.append([path_dijkstra[x],path_dijkstra[x+1]])
                
                for cores in source_destination:
                    path_length.append(length_matrix[cores[0]][cores[1]])
                
                LinkLength[i][j]=np.sum(path_length)
    return LinkLength

def Cost(adj_matrix,task_matrix,distance,traffic_data,num_nodes):
    
  
    
    hopCount_Matrix=np.zeros((num_nodes,num_nodes))
    linkLength_Matrix=np.zeros((num_nodes,num_nodes))
    cost_Vector=[]
    cost=0
    cost_Final=0
    # get the hop count matrix for the given design
    hopCount_Matrix=hop_count(adj_matrix,num_nodes)
    # calculating link length matrix for the configuration
    linkLength_Matrix=link_length(adj_matrix,distance,num_nodes) 
    # Calculate total cost for the configuration
    for i in range(num_nodes):
        for j in range(num_nodes):
            task=task_matrix[j]
            # calculating cost
            cost=((3*hopCount_Matrix[i][j] + math.ceil(linkLength_Matrix[i][j])) * traffic_data[task][i])
            cost_Vector.append(cost)
    cost_Final=np.sum(cost_Vector)
    return cost_Final

def decay_probability(Cnew,C,T):
    
   #calulating the decay.    
    del_T = Cnew - C
    decay_prob = math.exp(-del_T/T)
    return decay_prob

def simulated_annealing(traffic_data,T,Tth,alpha,num_iter):
    
   
    
    start=time.time()  # To get the start time
    num_nodes=64
    grid=8
   #Calculating distance
    Cal_Distance=calculate_distance(num_nodes,grid) 
    distance=np.array(Cal_Distance)    
    
    core_Connections=mesh_generate()
    Scurrent=adj_matrix(core_Connections)
    Tcurrent=[i for i in range(64)]  
    # Calculate cost for the Mesh design 
    Ccurrent=Cost(Scurrent,Tcurrent,distance,traffic_data,num_nodes)
    print("Cost function for Mesh",Ccurrent)
    # iterating until the temperature is greater than the Tth
    while T > Tth:
        for i in range(num_iter):
            # perform perturbration
            Sneigh,Tneigh = perturbation(Scurrent,Tcurrent)
            # Calculating the cost for the new configuration
            Cneigh=Cost(Sneigh,Tneigh,distance,traffic_data,num_nodes)
            # checking whether the new cost is better
            if Cneigh < Ccurrent:
            
                Scurrent=Sneigh
                Tcurrent=Tneigh
                Ccurrent=Cneigh
            else:
           
                a = decay_probability(Cneigh,Ccurrent,T)
                if a > random.uniform(0,1):
                    Scurrent=Sneigh
                    Tcurrent=Tneigh
                    Ccurrent=Cneigh        
        # Decay in the temperature using alpha 
        T = alpha*T
        
        print("Cost :",Ccurrent,"Temperature ",T)
    end=time.time()
    print("Total Execution Time:",end-start)
    return Scurrent,Tcurrent

traffic_uniform = pd.read_csv("traffic_uniform.csv", delimiter=",", header=None)
traffic_complement = pd.read_csv("traffic_complement.csv", delimiter=",", header=None)
traffic_random = pd.read_csv("traffic_rand.csv", delimiter=",", header=None)

T = 100
Tth = 0.5
alpha = 0.9
num_iter = 100
adj_matrix_rand,task_Matrix_rand=simulated_annealing(traffic_random,T,Tth,alpha,num_iter)
print(f'{task_Matrix_rand}', end= ' ')

adj_matrix_list = adj_matrix_rand.tolist()
for rows in adj_matrix_list:
  print(rows)

T = 100
Tth = 0.5
alpha = 0.9
num_iter = 100
adj_matrix_uniform,task_Matrix_uniform=simulated_annealing(traffic_uniform,T,Tth,alpha,num_iter)
print(f'{task_Matrix_uniform}', end=' ')

adj_matrix_list = adj_matrix_uniform.tolist()
for rows in adj_matrix_list:
  print(rows)

T = 100
Tth = 0.5
alpha = 0.9
num_iter = 100
adjacentMatrix_complement,task_Matrix_complement=simulated_annealing(traffic_complement,T,Tth,alpha,num_iter)
print(f'{task_Matrix_complement}', end=' ')

adj_matrix_list = adjacentMatrix_complement.tolist()
for rows in adj_matrix_list:
  print(rows)